##  プログラミングII　2024　課題レポート（第1回）

###  出題範囲：　プログラミングI～プログラミングII　第1回～第3回まで

###  提出期限：　2024/10/18(金) 17:00 　 （原則、1週間後の金曜夕方まで）

###  提出方法：

- Githubアカウントの作成
- Githubアカウントの通知：FORMSで回答する：　https://forms.office.com/r/jtyy76rnni
- プライベートリポジトリの作成
- プライベートリポジトリへ、``keythrive`` を招待し承諾を得る
- 10/10までにここまで実施する
- 課題に取り組む： Python環境は，Colaboratory, Jupyter，VSCodeなどでコード記述し，動作確認する
- 課題の回答，レポートは，本マークダウンファイル（WebClassからダウンロード）を書き換えて，自分の言葉で記述すること
- 生成AIの回答，他学生のレポート内容をコピー＆ペーストしてはいけません（不正行為，それ以上に，自分の成長を妨げる弊害だからです）
- わからない問題は，友達，４年生のSA（Student Assistant），学習支援センター，教員に質問して，必ず自分の理解とスキルにつなぐこと
- 各自のGithubのプライベートリポジトリ: https://github.com/アカウント/Programming2/report-01/ に、作成した課題レポートファイル一式をアップロード(push)、コミットする
- 提出期限まで、ファイルの差し替え・アップデートは自由に可能
- 提出期限を過ぎたら、教員が自動取得する（以降差し替え不可）

####  指導教員：　堀川

-------

レポート提出者：

|Aクラス|20124020|　佐藤大聖　|
|-|-|-|
|A or B| 20212____ |  ________ |


------


## 目次

 1.  問題１ リスト、タプル、計算式、例外
 2.  問題２ 内包表現
 3.  問題３ class、インスタンス、 メソッド
 4.  問題４ Stack と Queue

- 通常問題は、全員が回答が必須です。

- **[Extra Challenge]** とある問題は、エクストラ問題で、難しければスキップでもかまいません（減点はありません）。
挑戦者はぜひチャレンジしてください（Additional Point: 加点要素として考慮します）

----


-----

##  問題１ リスト、タプル、計算式　【通常問題、回答必須】

-----

リストかタプルで与えられた4つの数があります:

(例) d = (1,3,5,7)

1. タプルから４つの数値を取り出す
3. 四則演算(`+,-,*,/`)と`()`を使い、4つの数字から10をつくる
2. ``ten = 計算式`` を作成して、ten = 10になる計算式を組み立てる
4. assert文で``ten == 10``であることを確認する
5. ten !=  10なら例外：**AssertionError**を発生させる
6. 0で割り算する例外を想定して、例外**ZeroDeivisionError**に対応する

(例題)

    2, 0, 2, 3 を使って10をつくる



```python
try:
   d = (2,0,2,3)
   # タプルから４つの数値を取り出す:  2==d[0], 0==d[1], 2==d[2], 3==d[3]
   # 四則演算(+,-,*,/)と()を使い、4つの数字から10をつくる
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = (d[0] + d[3]) * (d[1] + d[2])
   ten = int(ten)   # 整数に整える
   # assert文で　ten == 10　であることを確認する
   # ten != 10ならAssertionErrorを派生させる
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.



----
#### この課題をクリアすることで得られるスキル・知識：
 いくつかの技法（お宝アイテム）を発見し、その価値を知る：
- 基本スキル：　リスト、タプル、例外(try: raise: except:)
- 応用スキル：　assert、eval
----


###  問題1 (1)  
    1,1,9,9 を使って10をつくる


```python
try:
   a,b,c,d = [1,1,9,9]
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten =　(a+b/c)*d
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
   raise e
```

    ゼロで割ったら無限大, so let's try it again
    division by zero



    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    <ipython-input-9-eb664ac7535b> in <cell line: 1>()
         11    print(f"ゼロで割ったら無限大, so let's try it again");
         12    print(e);
    ---> 13    raise e
    

    <ipython-input-9-eb664ac7535b> in <cell line: 1>()
          2    a,b,c,d = [1,1,9,9]
          3    # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
    ----> 4    ten = int(  10/0   )  #  10/0は間違い　→　10を作る計算式に書き換えて
          5    assert ten == 10, f"Ten is {ten}, not 10"
          6    print(f"Ten is {ten}, {ten} == 10.")


    ZeroDivisionError: division by zero


###  問題1 (2)  
    3, 4, 6, 6 を使って10をつくる



```python
try:
   a,b,c,d = (3, 4, 6, 6,)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = (b*c+d)/a
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (3)  
    4,6,6,9 を使って10をつくる



```python
try:
   a,b,c,d = (4, 6, 6, 9)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = (b+d)*a/c
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except  AssertionError　as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (4)  
    9,9,9,9 を使って10をつくる



```python
try:
   a,b,c,d = (9, 9, 9, 9)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = (a*b+c)/d
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (5)  
    1, 1, 5, 8 を使って10をつくる
   



```python
try:
   a,b,c,d = (1, 1, 5, 8)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = (d/(a-b/c))
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


## 問題１　まとめ

----
#### この課題をクリアすることで得られるスキル・知識：
 いくつかの技法（お宝アイテム）を発見し、その価値を知る：
- 基本スキル：　リスト、タプル、例外(try: raise: except)
- 応用スキル：　assert、eval
----

問題１で使った技法（お宝アイテム）について、**自分の言葉で**,価値やご利益を説明してください：

- タプルはどういう役割で使いましたか？

a,b,c,d を (3, 4, 6, 6,)に変換してつかった。

- リストはどういう役割で使いましたか？

[]この中の要素をほかの文字に変えられる
[1,1,9,9]をa,b,c,d,に変換して使った。

- try: except: 例外処理は何のために使いましたか？

エラー処理のために使った。

- assertは何の役割で使いましたか？

実行して成功したらTen is {ten}, {ten} == 10が出てきて、エラーだったら、AssertionErrorとなりprint(f"惜しい!  try again");が実行され惜しい!  try againと実行される

- ten = int()のint()は、何の役割で使いましたか？

文字列などを整数に変換するため

##### 参考（問題のヒント）：
- 文字列で与えられたコード（式）を実行する関数:  **eval()**


```python
expr = ( '(1+1/9)*9', '(4*6+6)/3', '(6+9)*4/6', '8/(1-1/5)', '(9*9+9)/9' )
for v in expr:
    f = f"int({v})"
    ten = eval(f)
    print(f"{v} = {ten}")
```

----------
----------

## 問題２： 内包表現　【通常問題、回答必須】

- 【初歩的質問】　なぜ、繰り返し・反復処理（ループ、イテレーション）を使う必要があるのでしょうか？
- コンピュータの強み：得意とするのが、高速計算と繰り返し処理だからです。1秒間に何十億もの計算・処理を実行します。車のエンジンの回転数：1分間に数千回転に比べても人間の計算スピードに比べても、圧倒的です。
- もしも、繰り返し処理がなければ、同じ処理を数十億回、プログラムコードで、書いて並べなくてはなりません。書くのも読むのも、途方に暮れる作業でしょう。
- 繰り返し処理は、通常、「ここから、ここまでを何回も繰り返す」として、複数の処理を囲む形で表記します。
- 内包表現を使えば、数十億回の繰り返しも、たった1行で書けるので、とても強力です。

**ループを使った場合：**
```python
squares = []
for x in range(1000):
    squares.append(x ** 2)
print(squares)
```

**内包表現を使った場合：**
```python
squares = [x ** 2 for x in range(1000)]
print(squares)
```

- リスト、タプル、辞書、集合、よく使うデータ構造には、それぞれ内包表現が使えて、強力です。
- 次の例題を参考に、問題を解いてください。

###### リスト内包表記の例

1. リスト内包表記を使って、数の二乗を含むリストを生成する。

`0`から`9`までの整数の二乗をリスト内包表記を使って生成してください。

```python
squares = [x ** 2 for x in range(10)]
print(squares)
# 出力: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```
2.  タプル内包表記の例

ジェネレータ内包表記を使うことでタプルの内包表現相当を実現できる。

`1`から`5`までの数の階乗を計算するジェネレータを作り、それをタプルに変換してください。

```python
import math
factorials = tuple(math.factorial(x) for x in range(1, 6))
print(factorials)
# 出力: (1, 2, 6, 24, 120)
```
3. 辞書内包表記

辞書内包表記を使って、キーと値のペアを生成する。

`0`から`9`までの整数をキー、各整数の二乗を値とする辞書を辞書内包表記を使って生成してください。

```python
square_dict = {x: x ** 2 for x in range(10)}
print(square_dict)
# 出力: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

```
4. 集合内包表記の例
集合内包表記を使って、一意の値を持つ集合を生成する。

`0`から`9`までの数のうち、偶数だけを含む集合を集合内包表記を使って生成してください。

```python
even_set = {x for x in range(10) if x % 2 == 0}
print(even_set)
# 出力: {0, 2, 4, 6, 8}
```

#### 問題2-1

リスト、タプル、辞書、集合の内包表記を使って、以下のデータ構造を作成してください：

1. `0`から`9`までの整数の立方数を含むリスト

2. `10`から`20`までの整数のうち奇数を含むジェネレータをタプルに変換

3. 任意の文字列の各文字をキー、文字のUnicodeコードポイントを値とする辞書

4. 任意の数値のリストから、負の数のみを含む集合



```python
# 1. 立方数リスト
cubes = [x ** 3 for x in range(10)]
```
print(cubes)
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]


```python
# 2. 奇数のジェネレータからタプル
odd_numbers = tuple(x for x in range(10, 21) if x % 2 != 0)
```
print(odd_numbers)
(11, 13, 15, 17, 19)


```python
# 3. 文字列の文字をキー、Unicodeコードポイントを値とする辞書
string = "Hello World."
char_to_unicode = {char: ord(char) for char in string}
```
print(char_to_unicode )
{'H': 72, 'e': 101, 'l': 108, 'o': 111, ' ': 32, 'W': 87, 'r': 114, 'd': 100, '.': 46}

```python
# 4. 負の数のみの集合
numbers = [3, -1, -5, 8, 0, -3, 7]
negative_set = {x for x in numbers if x < 0}
```
print(negative_set)
{-5, -3, -1}


----------
----------

## 問題３： Class、メソッド、インスタンス

**class**を使って、**コラッツ予想**（コラッツの問題）を試してみる

**コラッツ予想**とは：　正の整数 $n$ を初期値として、次の$n$を次のように計算する：

- $n$が奇数ならば、　3倍して1を足す $n \to 3*n+1 $
- $n$が偶数ならば、　2で割る  $n \to n / 2 $

を繰り返すと，最後は必ず $ n=1 $ で終了するという予想

参考：　https://www.nhk.jp/p/ts/Y5R676NK92/blog/bl/pmg0p5PX8L/bp/pn8omzj69Y/


----

#### 問題3-1:  ロジックの穴埋め、動作確認
- 次のコードの３つの空欄A,B,Cに、適切なコードを記述する

|空欄|適切なコードに書き換えてください|
|-|-|
|A|```  (n // 2)  ```|
|B|```  (3 * n + 1)  ```|
|C|```  (n)  ```|

- 動作確認：　期待するアウトプットを出力することを確認する

    - 期待する出力
          [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
          35
          [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
          10
          [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
          86

- 次の質問について、**自分の言葉で**　考えを説明する：

    - この例で，クラスの定義は、どこからどこまで、どのように設計されていますか？
    ```
      自分の考え・見解を記入
    ```class Cclatz:からreturn len(self._seqまで_init_)メゾットを使ってnという引数を取り、self._seqがリストとして定義される。
    
    - この例で，メソッドの定義は、いくつあって、どれとどれで、どのように設計されていますか？
    ```
      自分の考え・見解を記入
    ```_init_, self._seqという名前のリスト[n]を作る。
    calc, 計算の答えが1になるまでの過程を記録し、返す。
    _len_,数例の要素数を返す。

    - この例で，インスタンスは、どれですか？　どうやって作られて、どこに実体がありますか？
    ```
      自分の考え・見解を記入
    ```c = Collstz(n)で作られる。
    forループの中に実体がある。

    - インスタンスに対して、メソッドを呼び出しているのはどこですか？
    ```
      自分の考え・見解を記入
    ```print(c.calc())とprint(len(c))


```python
### Collatzクラスとメソッドを設計・定義する

class Collatz:
  def __init__(self, n):
    self._seq = [n]

  def calc(self):
    n =  self._seq[-1]
    while n !=1:
      n = (n // 2) if n%2==0 else (3 * n + 1)
      self._seq.append(n)
    return self._seq

  def __len__(self):
    return len(self._seq)

### Collatzクラスのインスタンスを作って、メソッドを使う

Ns = [237, 512, 31415]

for n in Ns:
  C = Collatz(n)
  print(C.calc())
  print(len(C))

```

    [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    35
    [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
    10
    [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    86


----
#### この課題をクリアすることで得られるスキル・知識：
 いくつかの技法（お宝アイテム）を発見し、その価値を知る：
- 基本スキル：　クラス、メソッド、``self``パラメタ, インスタンスの作り方、メソッドの呼び出し方,　特殊メソッド（```__init__(self):```、```__len__(self):```など）
----

##### 問題3-2 [Extra　Challenge]　チャレンジ問題：ジェネレータ

-  ジェネレータを使って書き換えてください
- ジェネレータ式は、教科書pp.51, ジェネレータ,**yield**は、教科書pp.131-　さきどり着手です。

|空欄|適切なコードに書き換えてください|
|-|-|
|D|```  ('空欄D')  ```|
|E|```  ('空欄E')  ```|
|F|```  ('空欄F')  ```|


```python

class Collatz:
    def __init__(self, n):
        self.n = n

    def calc(self):
        n = self.n
        while n != 1:
            yield ('空欄D')
            n = n // 2 if n % 2 == 0 else 3 * n + 1
        yield ('空欄E')

Ns = [237, 512, 31415]
for d in Ns:
  C = Collatz(d)
  seq = [ n for n in ('空欄F') ]
  print(len(seq))
  print(seq)

```

    35
    [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    10
    [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
    86
    [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]


---
---

## 問題４

### **Stack クラスと Queue クラスの設計と実装**

#### この課題をクリアすることで得られるスキル・知識：
 いくつかの技法（お宝アイテム）を発見し、その価値を知る：
- 基本スキル：　クラス、メソッド、``self``パラメタ, インスタンスの作り方、メソッドの呼び出し方,　特殊メソッド（```__init__(self):```など）
- 有用なデータ構造のクラス設計，オブジェクト指向，抽象データ型の設計思想と，スタックとキューの設計・動作確認を実践し，鍵となる理論的概念、実践的な実装、問題解決、効率性を理解する．

----

1.  **スタック**とは
    -  *LIFO* 構造：*Last In First Out* = 新しいもの（最後に入れたもの）を最初に取り出すデータ構造
    -  実生活での例: 新聞，雑誌，皿を積み重ねる
    -  内部状態として，リストなどコレクションと，入口＝出口を示すスタックポインタ(*sp*)をもつ
    -  スタックに対する意味のある操作（メソッド）として，次のようなものがある：
    -  `push(data)` 操作： *data*を追加する
    -  `data = pop()` 操作： 最後に追加した*data*を取り出して削除
    -  `peek()` で一番上の*data*を削除せずに調べる
    -  `is_empty()`で，空かどうかを調べる
    -  `is_full()`で，満杯かどうかを調べる
    
2. **キュー**とは
    -   *FIFO* 構造：*First In First Out* = 最初に入れたもの（古いもの）を最初に取り出すデータ構造
    -  実生活での例: アトラクション，人気店，チケットカウンターの待ち行列
    -  内部状態として，リストなどコレクションと，最前列を示すヘッド(*head*)，最後尾を示すテイル(*tail*)をもつ
    -  キューに対する意味のある操作（メソッド）として，次のようなものがある：
    -  `enqueue(data)` 操作：最後尾に*data*を追加する
    -  `data = dequeue()` 操作：待ち行列の先頭の*data*を取り出して削除
    -  `peek()` ：先頭の*data*を削除せずに調べる
    -  `is_empty()`で，空かどうかを調べる
    -  `is_full()`で，満杯かどうかを調べる
---
#### 問題4-(1): ユースケースの比較
- スタックとキューは、さまざまなシーンで使われる有用なデータ構造です．
- 次のユースケースごとに、`Stack` と `Queue` のどちらがより適切か選択し、その理由を説明してください:

1. Web ブラウザーの戻るボタン機能：
   - `Stack` $or$ `Queue` が適切  Stack
   - なぜならば，.....　と考えるから ブラウザの出口になるから

2. オフィスのプリンタのジョブ：
   - `Stack` $or$ `Queue` が適切　Queue
   - なぜならば，.....　と考えるから　進行度を知ることができるから

3. 括弧を含む数式の評価 (例: `((1 + 2) * 3)`)：
   - `Stack` $or$ `Queue` が適切　stack
   - なぜならば，.....　と考えるから　()内の数から計算を重ねていく行程積み重ねていくと考えているから。
  
---
#### 問題4-(2): Pythonクラス設計

- 基本的なスタック機能とキュー機能を実装する Python クラス `Stack` とクラス `Queue` を設計して, Pythonで記述してください
   
- クラスには，少なくとも次のメソッドを含める必要があります:
- `Stack` : `push()`,`pop()`,`is_empty()`
- `Queue` : `enqueue()`,`dequeue()`,`is_empty()`

- 空の状態にも関わらず，データを取り出そうとするケース：pop()またはdequeue()などのエッジケース(例外処理)に対応してください

---
```python

class Stack:
   """
   """
   def __init__(self):
      self._satck = []
   
   def push(self,data):
      self._stack.append(data)

   def pop(self):
      if self._is_empty():
         print("Error! pop is empty")
         return 
      else:
         raise self.stack.pop

   def is_empty(self):
      return len(self.stack) == 0

stack = stack()

stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
stack.push(5)
stack.push([1,2,3,4,5])

print(satck.pop())
print(satck.pop())
print(satck.pop())
print(satck.pop())
print(satck.pop())
print(satck.pop())
print(satck.pop())

```

```python
[1,2,3,4,5]
5
4
3
2
1
Error! pop is empty


class Queue:
   """
   """
   def __init__(self):
      self.queue = []
   
   def enqueue(self,data):
      self.queue.append(data)

   def dequeue(self):
      if self.is_empty():
         print("Error! pop is empty")
      else:
         raise self.queue.pop

   def is_empty(self):
      return len(self.queue) == 0
    
queue = queue()

queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
queue.enqueue(4)
queue.enqueue(5)

print(queue.dequeue())
print(queue.dequeue())
print(queue.dequeue())
print(queue.dequeue())
print(queue.dequeue())
print(queue.dequeue())
```
python
1
2
3
4
5
Error! dequeue is emrty
None
---
#### 問題4-(3): 動作確認，実装のテスト (コード実行)

`Stack` クラスと `Queue` クラスを設計しコードを記述したら，次は動作確認です．
期待した動作ができているか，次の操作でコードをテストしてください:

1. **Stack**:
- スタックに 5 つの要素をプッシュします (例: `[1、2、3、4、5]`)
- スタックが空になるまで、一連のポップ操作を実行します
- is_empty()で空かどうかチェックします
- 空のスタックから再度 `pop()` を試し、例外処理を確認します
[1, 2, 3, 4, 5]
5
4
3
2
1
Error! pop is empty
None

1. **Queue**:
- 5 つの要素をキューに追加します (例: `[1, 2, 3, 4, 5]`)
- キューが空になるまで、一連のデキュー操作を実行します
- is_empty()で空かどうかチェックします
- 空のキューから再度 `dequeue()` を試し、例外処理を確認します
1
2
3
4
5
Error! dequeue is empty
None

---
#### 問題4-(4): [Extra　Challenge]　チャレンジ問題：スタックとキューによる応用

- `Queue` オブジェクトを引数として受け取り、要素を逆順にした新しいキューを返す関数 `reverse_queue(q: Queue)` を記述してください
- 実装した `Queue` クラスと `Stack` クラスのみ使用できます
- それ以外，リストや配列などの追加のデータ構造は使用できません
---





-----
-----

## 参考，Coffee Break Addtional

深さ優先探索 (DFS)、幅優先探索 (BFS)、最良優先探索 (ヒープを使用) など、グラフ トラバーサル アルゴリズムにおけるスタック、キュー、ヒープの適用に関する理解をさらにテストするための詳細な例と説明

---

### 検索アルゴリズムにおけるスタック、キュー、ヒープの適用

#### **深さ優先探索 (DFS) とスタック (実装 + 説明)**
**深さ優先探索 (DFS)** は、グラフ内のすべての可能なパスを探索するために使用されるアルゴリズムです。DFS は、**LIFO (後入れ先出し)** の性質上、通常、スタックを使用して実装されます。

- 指定されたノードから開始して、無向グラフで深さ優先探索を実行する関数 `dfs(graph: dict, start: str)` を記述します。グラフは、キーがノードで値が隣接するノードのリストである辞書として表されます。

たとえば、次のグラフがあるとします:
```python
graph = {
'A': ['B', 'C'],
'B': ['D', 'E'],
'C': ['F'],
'D': [],
'E': ['F'],
'F': []
}
```
関数は深さ優先順にノードを訪問し、訪問したノードのリストを返す必要があります。

----

- **実装におけるスタックの役割について質問**。
　スタックを使用して DFS はどのように機能し、深さ優先探索に適しているのはなぜですか?

----

#### **幅優先探索 (BFS) とキュー (実装 + 説明)**
**幅優先探索 (BFS)** は、グラフ内のノードをレベルごとに探索するために使用されるアルゴリズムです。キューを使用するのは、**FIFO (先入れ先出し)** の性質があるためです。これにより、最も近いノード (レベル別) が最初に探索されます。

- 指定されたノードから開始してグラフの幅優先探索を実行する関数 `bfs(graph: dict, start: str)` を記述します。DFS の質問と同じグラフ表現を使用します。

----

- **実装におけるキューの役割** について質問：　BFS がキューに適しているのはなぜですか。また、最も近いノードが最初に探索されることをどのように保証しますか。

- **実際の例**: BFS を使用して、重み付けされていないグラフで最短パスを見つける方法について説明します。たとえば、地図上のある都市から別の都市への最短ルートを見つけるなど

----

#### **最良優先探索とヒープ (実装 + 説明)**
**最良優先探索** は、(何らかのヒューリスティックに基づいて) 最もコストが低いノードが最初に探索されるグラフ トラバーサル アルゴリズムです。これは、**ヒープ (優先キュー)** を使用して実装できます。これにより、コストが最小のノードが常に最初に探索されます。

- 最良優先検索を実装する関数 `best_first_search(graph: dict, start: str, goal: str, heuristic: dict)` を作成します。グラフは隣接リストとして表され、ヒューリスティック関数は各ノードからゴールまでの推定距離を含む辞書として提供されます。**ヒープ** を使用して探索するノードの境界を管理し、ヒューリスティック値が最小のノードが最初に探索されるようにします。

```python
graph = {
'A': ['B', 'C'],
'B': ['D', 'E'],
'C': ['F'],
'D': [],
'E': ['F'],
'F': []
}

heuristic = {
'A': 6, 'B': 4, 'C': 5,
'D': 3, 'E': 2, 'F': 1
}
```
この関数は、目標ノードに到達することを目指して、最良優先順に訪問されたノードのリストを返す必要があります。

----
- **実装におけるヒープ** (優先キュー) の役割について説明してください。最良優先探索での探索プロセスをどのように最適化しますか?

- **比較**: 最良優先探索と BFS の動作を比較します。戦略と探索効率の点で、両者はどのように異なりますか?
----

#### DFS、BFS、およびベスト ファースト サーチの実践 (比較と考察)

1. **DFS と BFS**: DFS が BFS よりも優れた選択肢となるシナリオ、およびその逆について説明します。
- DFS の例: 迷路のすべての可能な解決策の探索。
- BFS の例: 都市マップで最短経路の検索。

2. **ベスト ファースト サーチの適用**: 宝物への最短ルートを見つける必要があるゲームで、ベスト ファースト サーチ (適切なヒューリスティックを使用) を適用して効率的に目標に到達する方法を説明します。

3. **考察**: 各アルゴリズム (DFS、BFS、およびベスト ファースト サーチ) の長所と短所を、時間と空間の複雑さ、およびさまざまな種類の問題への適合性の観点から説明します。

